---
title: "XXX"
description: |
    Process raw data.
author:
  - name: Miko≈Çaj Biesaga and Szymon Talaga
    affiliation: The Robert Zajonc Institute for Social Studies
    affiliation_url: www.iss.uw.edu.pl/en/
---

```{r setup_env, include=FALSE}
# Globals
ROOT <- here::here()
HERE <- file.path(ROOT, "notebooks")
DATA <- file.path(ROOT, "data", "proc")
```

```{r setup}
## Load necessary packages
library(magrittr)
library(tidyverse)
library(broom)
library(reticulate)
library(haven)
library(zoo)

## Activate Conda environment
use_condaenv("bdm")
```

\subsection{Study 1}

```{r load_and_prepare_data}
## Load Study 1. raw data
data <- read_delim(file.path(ROOT,"data/Study_1.csv"), delim = ";") %>%
    rename_at(vars(matches("^\\d")), ~str_c("d", .x)) %>%
    mutate_at(vars(matches("^d\\d")), as.integer) %>%
    rename(id = X)

## Transform to long format
data_long <- gather(data, key = "Index", value = "Bit", matches("^d\\d")) %>%
    filter(!is.na(Bit)) %>%
    arrange(id) %>%
    group_by(id) %>% 
    mutate(idx = 1:n()) %>%
    filter(idx < 313) %>%
    summarize(seq = list(Bit)) %>%
    ungroup 
``` 


```{python compute_bdm}
import numpy as np
import pandas as pd
from pybdm import BDM
from pybdm import PartitionIgnore, PartitionRecursive

def window_bdm(seq, bdm, k=8):
    return np.array([ bdm.bdm(seq[i:(i+k)]) for i in range(len(seq) - k) ])
    
data = r.data_long
data.id = data.id.astype(int)
data.seq = data.seq.apply(lambda x: np.array(x, dtype=int))

bdm_recursive = BDM(ndim=1, partition=PartitionRecursive, min_length=8)
bdm_ignore = BDM(ndim=1, partition=PartitionIgnore)
seq8 = pd.DataFrame({'id': r.data_long.id.astype(int),
                     'cmx': data.seq.apply(bdm_ignore.nbdm),
                     'cmx_w': data.seq.apply(lambda x: window_bdm(x, bdm_recursive, k = 8))})
```


```{r data_processing}
## Read python object to R
seq8 <- as_tibble(py$seq8)

## Join bdm matrix with data
data <- select(data, -matches("^d\\d")) %>%
    filter(id %in% seq8$id) %>%
    left_join(select(seq8, id, cmx), by = "id") %>%
    mutate(Condition = case_when(Condition == "coin" ~ "Coin Tossing",
                                 Condition == "stock" ~ "Stock Market",
                                 Condition == "zero" ~ "No Instruction"))
   
           
## Prepare data for more detailed analysis
seq8 <- seq8 %>%
    unnest(cols = cmx_w) %>%
    mutate(cmx_w = as.vector(cmx_w)) %>%
    group_by(id) %>%
    mutate(idx = 1:n(),
           cmx_r = rollmean(cmx_w, k = 8, align = "center", na.pad = TRUE)) %>%
    ungroup %>%
    left_join(select(data, -cmx), by = "id") %>%
    filter(idx < 313)  %>%
    mutate(cmx_wc = cmx_w - mean(cmx_w))

## Write out processed data sets

write.csv2(seq8, file.path(ROOT, "data","proc","Study1_seq8.csv"))
write.csv2(data, file.path(ROOT, "data","proc","Study1.csv"))
```


\subsection{Study 2.}


```{r load_and_prepare_data2}
## Load Study 2. raw data
data2 <- read_sav(file.path(ROOT,"data/Study_2.sav")) %>%
  mutate(id = 1:n()) %>%
  select(-Id) %>%
  filter(survey_finish_time >= 656 & survey_finish_time < 1708) %>%
  rename_at(vars(matches("^v1_r\\d+")),
            ~str_extract(string = .x, pattern = '\\d+$') %>%
              str_c("pzp", .)) %>%
  rename_at(vars(matches("^v2_r\\d+")),
            ~str_extract(string = .x, pattern = '\\d+$') %>%
              str_c('pp', .)) %>%
  mutate_at(vars(matches("pp\\d+")), ~as.numeric(.)) %>%
  mutate_at(vars(matches("pzp\\d+")), ~as.numeric(.))
```

```{r scales_calculations}
## Compute Need for Cognition and Need for Closure results
data2 <- data2 %>%
  mutate_at(vars(matches("pp[2, 3, 8, 10, 13, 15, 17, 19, 22, 26, 28, 33, 34, 35]")), ~{6-.}) %>%
  mutate_at(vars(matches("pzp[2, 5, 10, 14, 15, 16, 17, 18, 20, 24, 30, 31]")), ~{7-.}) %>%
  mutate(year = as.numeric(year)) %>%
  select(-age) %>%
  rowwise() %>%
  mutate(preferowanie_porzadku = sum(pzp1, pzp6, pzp17, pzp19, pzp26, pzp27, pzp28),
         preferowanie_przewidywalnosci = sum(pzp5, pzp7, pzp9, pzp15, pzp16, pzp21, pzp22, pzp32),
         nietolerowanie_wieloznacznosci = sum(pzp3, pzp8, pzp12, pzp24, pzp25, pzp29),
         zamknietosc_umyslowa = sum(pzp2, pzp4, pzp20, pzp23, pzp30, pzp31),
         zdecydowanie = sum(pzp10, pzp11, pzp13, pzp14, pzp18),
         preferowanie_porzadku2 = sum(pzp6, pzp26, pzp27),
         preferowanie_przewidywalnosci2 = sum(pzp9, pzp21, pzp32),
         nietolerowanie_wieloznacznosci2 = sum(pzp3, pzp8, pzp29),
         zamknietosc_umyslowa2 = sum(pzp2, pzp20, pzp31),
         zdecydowanie2 = sum(pzp13, pzp14, pzp18),
         potrzeba_poznania = sum(pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10,
                                 pp11, pp12, pp13, pp14, pp15, pp16, pp17, pp18, pp19, pp20,
                                 pp21, pp22, pp23, pp24, pp25, pp26, pp27, pp28, pp29, pp30,
                                 pp31, pp32, pp33, pp34, pp35, pp36),
         warunek = as.character(warunek),
         warunek = if_else(warunek == "1", "homogeneous", "heterogeneous")) %>%
  select(-matches('pp\\d+|pzp\\d+'))

# Transform data to long format
data2_time <- data2 %>%
  gather(key = "Index", value = "Bit", matches("war[[:digit:]]")) %>%
  filter(!is.na(Bit)) %>% 
  filter(Bit != 99) %>% 
  mutate(klucz = if_else(grepl(x = Index, pattern = "time"), 'time', 'seq'),
         ids = str_extract(Index, pattern = '^war1_\\d+|^war2g\\d+_|^war2rm\\d+_'),
         ids = if_else(grepl(x = ids, pattern = 'war1'),
                       str_extract(string = ids, pattern = '(\\d+)(?!.*\\d)'),
                       str_extract(string = ids, pattern = '([rmg]+\\d+)(?!.*\\d)')),
         ids = case_when(ids == 'rm1' ~ '1',
                         ids == 'g1' ~ '2',
                         ids == 'rm2' ~ '3',
                         ids == 'g2' ~ '4',
                         ids == 'rm3' ~ '5',
                         ids == 'g3' ~ '6',
                         ids == 'rm4' ~ '7',
                         ids == 'g4' ~ '8',
                         ids == 'rm5' ~ '9',
                         ids == 'g5' ~ '10',
                         TRUE ~ ids),
         ids = as.numeric(ids)) %>%
  select(id, ids, Bit, klucz) %>%
  group_by(id, ids, klucz) %>%
  mutate(idx = 1:n()) %>%
  spread(klucz, Bit) %>%
  filter(!is.na(seq))

data2_long <- data2_time %>%
  select(id, ids, seq) %>%
  group_by(id, ids) %>%
  summarise(seq = list(seq)) %>%
  filter(lengths(seq)>2)
```

```{python compute_bdm2}
import numpy as np
import pandas as pd
from pybdm import BDM
from pybdm import PartitionIgnore, PartitionRecursive
    
data = r.data2_long
data.id = data.id.astype(int)
data.ids = data.ids.astype(int)
data.seq = data.seq.apply(lambda x: np.array(x, dtype = int))

bdm = BDM(ndim=1, partition=PartitionRecursive)
seq = pd.DataFrame({'id': r.data2_long.id.astype(int),
                     'ids': r.data2_long.ids.astype(int),
                     'cmx': data.seq.apply(bdm.nbdm)})
```

```{r prepare_data_for_models}
## Load python object to R
seq <- py$seq

## Join bdm matrix with data
data2 <- data2_long %>%
  select(id, ids) %>%
  left_join(data2) %>%
  left_join(seq %>% select(id, ids,cmx)) %>%
  select(-matches('war\\d.')) %>%
  left_join(data2_time %>% select(id, ids, idx, time) %>% group_by(id,ids) %>% summarise(time = sum(time))) 

## Write out processed data set
write.csv2(data2, file.path(ROOT,"data","proc","Study2.csv"))
```
